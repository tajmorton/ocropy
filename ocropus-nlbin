#!/usr/bin/env python

import argparse
import logging
import multiprocessing
import os
import os.path

import ocrolib
from ocrolib.binarization import binarize_image 


def process1(job):
    fname, i, output_dir, config = job
    logger.info("Processing {file} ({num})".format(file=fname, num=i))

    output_fname = os.path.join(output_dir, "%04d.bin.png" % i)
    norm_fname = os.path.join(output_dir, "%04d.nrm.png" % i)
    raw_fname = os.path.join(output_dir, "%04d.raw.png" % i)
    return binarize_image(fname,
                          output_fname=output_fname,
                          output_raw_fname=raw_fname,
                          output_norm_fname=norm_fname,
                          **config)


if __name__ == "__main__":
    logging.basicConfig(format="%(levelname)s %(name)s (%(process)d): %(message)s")
    logger = logging.getLogger("ocropus.nlbin")
    logger.setLevel(logging.INFO)

    parser = argparse.ArgumentParser("""
    Image binarization using non-linear processing.

    This is a compute-intensive binarization method that works on degraded
    and historical book pages.
    """)

    parser.add_argument('-n', '--nocheck', action="store_true",
                        help="disable error checking on inputs")
    parser.add_argument('-t', '--threshold', type=float, default=0.5,
                        help='threshold, determines lightness')
    parser.add_argument('-z', '--zoom', type=float, default=0.5,
                        help='zoom for page background estimation, '
                        'smaller=faster')
    parser.add_argument('-e', '--escale', type=float, default=1.0,
                        help='scale for estimating a mask '
                        'over the text region')
    parser.add_argument('-b', '--bignore', type=float, default=0.1,
                        help='ignore this much of the border '
                        'for threshold estimation')
    parser.add_argument('-p', '--perc', type=float, default=80,
                        help='percentage for filters')
    parser.add_argument('-r', '--range', type=float, default=20,
                        help='range for filters')
    parser.add_argument('-m', '--maxskew', type=float, default=2,
                        help='skew angle estimation parameters (degrees)')
    parser.add_argument('-g', '--gray', action='store_true',
                        help='force grayscale processing '
                        'even if image seems binary')
    parser.add_argument('--lo', type=float, default=5,
                        help='percentile for black estimation')
    parser.add_argument('--hi', type=float, default=90,
                        help='percentile for white estimation')
    parser.add_argument('--skewsteps', type=int, default=8,
                        help='steps for skew angle estimation (per degree)')
    parser.add_argument('--progress', type=int, default=0, metavar='N',
                        help='display intermediate results for [N] seconds')
    parser.add_argument('--show', action='store_true',
                        help='display final result')
    parser.add_argument('--rawcopy', action='store_true',
                        help='write raw image to output directory')
    parser.add_argument('-o', '--output', default=None,
                        help="output directory")
    parser.add_argument('files', nargs='+')
    parser.add_argument('-Q', '--parallel', type=int, default=0,
                        help='number of images to process simultaneously')
    args = parser.parse_args()

    args.files = ocrolib.glob_all(args.files)

    if len(args.files) < 1:
        parser.print_help()
        sys.exit(0)

    if args.parallel > 1 and (args.progress > 0 or args.show > 0):
        logger.warning("Cannot use multiple threads when showing "
                       "results or progress. Using single thread.")
        args.parallel = 0

    if args.output:
        if not os.path.exists(args.output):
            os.mkdir(args.output)
    else:
        args.output = os.getcwd()

    binarization_config = {
        "progress_timeout": args.progress,
        "validate_image": not args.nocheck,
        "force_grayscale_conversion": args.gray,
        "whitelevel_scale_amount": args.zoom,
        "whitelevel_percentile": args.perc,
        "whitelevel_range": args.range,
        "max_skew_angle": args.maxskew,
        "skew_step_angle": args.skewsteps,
        "border_ignore_amount": args.bignore,
        "text_region_mask_scale": args.escale,
        "black_est_percentile": args.lo,
        "white_est_percentile": args.hi,
        "binarization_threshold": args.threshold,
    }

    if args.parallel < 2:
        for i, f in enumerate(args.files):
            image = process1((f, i+1, args.output, binarization_config))
            if args.show:
                dshow(image, "%s (%d)" % (f, i), 0)
    else:
        pool = multiprocessing.Pool(processes=args.parallel)
        jobs = []

        for i, f in enumerate(args.files):
            jobs += [(f, i+1, args.output, binarization_config)]
        result = pool.map(process1, jobs)
